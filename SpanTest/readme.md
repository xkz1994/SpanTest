# Span<T> 结构
---
- 提供任意内存连续区域的类型安全与内存安全表示形式
- NET Core 2.0 引入了 `Span<T>`和 `ReadOnlvSpan<T>`, 它们是可由托管或非托管内存提供支持的轻量级内存缓冲区。由于这些类型只能存诸在堆栈上
- 因此它们不适用于多种方案，包括异步方法调用
- `Span<T>`是在`stack`上而不是托管堆上分配的`ref struct`
- `ref struct`类型具有许多限制，以确保它们无法提升到托管堆, 包括无法装箱、无法分配给类型`Object`，`dynamic`变量或`任何接口`类型
- 它们不能是引用类型的字段，并且不能跨`await`或`yield`使用(跨函数调用)

# 如何编写出性能更好的代码
---
- C#提供了可编写性能更好的可验证安全代码的功能。`unsafe`
- 若仔细地应用这些技术，则需要不安全代码的方案更少(`span``ref``struct``intptr(nint)`等)。
- 利用这些功能，可更轻易地将对值类型的引用用作方法参数和方法返回。安全完成后，这些技术可以最大程度地减少值类型的复制操作。通过使用值类型，可以使分配和垃圾回收过程的数量降至最低。
- 使用值类型的优点之一是通常可避免堆分配。缺点是它们按值进行复制。由于存在这种折衷，因此难以优化针对大量数据执行的算法。
---
- 这些技术在两个目标之间取得平衡
	1. 最大限度地减少堆上的分配
		- 属于引用类型的变量包含对内存中位置的引用，并且分配在托管堆上。将引用类型作为参数传递给方法或从方法返回时，将仅复制引用。每个新对象都需要一个新的分配，并且随后必须回收。垃圾回收需要一些时间。
	2. 最大限度地减少值的复制。`Intptr(64位系统 8字节指针)`，`int double long(4-16字节)`
		- 基本类型不需要`ref` 因为也会造成指针8字节浪费
		- 属于值类型的变量直接包含其值，通常在将值传递给方法或从方法返回时将其复制。此行为包括在调用迭代器和结构的异步实例方法时复制this的值。复制操作需要一些时间，具体取决于类型的大小。
# 防御性副本
---
- 仅当使用`readonly`修饰符声明`struct`或方法仅访问该结构的`readonly`成员，才将其作为`in`参数传递。否则，编译器必须在许多情况下创建"防御性副本"以确保不会转变参数